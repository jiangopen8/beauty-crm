# 角色管理功能测试文档

## 文档信息
- **模块名称**: 角色管理
- **页面路径**: /roles.html
- **API路由**: /api/roles
- **测试目的**: 验证角色创建、权限分配、用户关联、状态管理等功能的数据库操作正确性
- **文档版本**: 2.0
- **更新日期**: 2025-12-09

---

## 一、功能概述

角色管理模块负责系统角色的定义、权限配置和用户关联管理，是实现基于角色的访问控制（RBAC）的核心模块。

### 核心功能
1. 角色信息管理（创建、查询、更新）
2. 角色权限配置（多对多关系）
3. 用户角色分配
4. 数据权限范围控制
5. 角色状态管理（启用/停用）
6. 角色统计分析

### 重要业务规则
⚠️ **角色管理特殊规则**:
- **不支持删除**: 角色只能启用/停用，不能删除
- **原因**: 保护权限系统稳定性，支持审计追溯
- **替代方案**: 通过修改 `status` 字段实现停用

---

## 二、数据库表结构

### 2.1 主表：roles

```sql
CREATE TABLE `roles` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `role_code` varchar(50) NOT NULL COMMENT '角色代码',
  `role_name` varchar(50) NOT NULL COMMENT '角色名称',
  `description` varchar(200) DEFAULT NULL COMMENT '角色描述',
  `data_scope` enum('all','org','store','self') NOT NULL DEFAULT 'self' COMMENT '数据权限范围',
  `status` enum('active','inactive') NOT NULL DEFAULT 'active' COMMENT '状态',
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `created_by` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `is_deleted` tinyint(1) NOT NULL DEFAULT '0' COMMENT '软删除标记',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_role_code` (`role_code`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='角色表';
```

**字段说明**:

| 字段名 | 类型 | 必填 | 说明 | 业务规则 |
|--------|------|------|------|----------|
| id | bigint | 是 | 主键 | 自增 |
| role_code | varchar(50) | 是 | 角色代码 | 唯一，英文标识，创建后不可修改 |
| role_name | varchar(50) | 是 | 角色名称 | 中文显示名 |
| description | varchar(200) | 否 | 角色描述 | 说明角色职责 |
| data_scope | enum | 是 | 数据权限 | all/org/store/self |
| status | enum | 是 | 状态 | active/inactive（用于启用/停用） |
| is_deleted | tinyint(1) | 是 | 软删除 | 保留字段，当前业务不使用删除功能 |
| created_at | timestamp | 是 | 创建时间 | 自动设置 |
| updated_at | timestamp | 是 | 更新时间 | 自动更新 |

**data_scope说明**:

| 值 | 含义 | 数据范围 | 典型角色 |
|----|------|---------|---------|
| all | 全部数据 | 可查看所有组织数据 | 系统管理员、数据分析师 |
| org | 组织数据 | 仅本组织数据 | 门店经理 |
| store | 门店数据 | 仅本门店数据 | 店长 |
| self | 个人数据 | 仅个人创建/负责的数据 | 美容顾问、销售专员 |

**status字段说明**:

| 值 | 含义 | 业务规则 | 使用场景 |
|----|------|---------|---------|
| active | 启用 | 角色正常可用，可分配给用户 | 正常业务使用 |
| inactive | 停用 | 角色暂停使用，已分配的用户保留角色但权限失效 | 临时停用、废弃角色 |

### 2.2 关联表：user_roles

```sql
CREATE TABLE `user_roles` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '关联ID',
  `user_id` bigint unsigned NOT NULL COMMENT '用户ID',
  `role_id` bigint unsigned NOT NULL COMMENT '角色ID',
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `created_by` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_user_role` (`user_id`,`role_id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_role_id` (`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户角色关联表';
```

### 2.3 权限表：role_permissions

```sql
CREATE TABLE `role_permissions` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '权限ID',
  `role_id` bigint unsigned NOT NULL COMMENT '角色ID',
  `permission_code` varchar(100) NOT NULL COMMENT '权限代码',
  `resource_type` varchar(50) DEFAULT NULL COMMENT '资源类型',
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `created_by` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_role_permission` (`role_id`,`permission_code`),
  KEY `idx_role_id` (`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='角色权限表';
```

**字段说明**:

| 字段名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| id | bigint | 是 | 主键 | 自增 |
| role_id | bigint | 是 | 角色ID | 外键 |
| permission_code | varchar(100) | 是 | 权限代码 | customer.view, order.create |
| resource_type | varchar(50) | 否 | 资源类型 | customer, order, user |

---

## 三、业务流程

### 3.1 创建角色流程

```
开始
  ↓
前端：填写角色信息
  ↓
API: POST /api/roles
  ↓
验证：角色代码唯一性
  ↓
插入：roles 表
  ↓
获取：新角色ID
  ↓
（可选）配置权限
  ↓
批量插入：role_permissions 表
  ↓
返回：成功
  ↓
结束
```

### 3.2 分配角色给用户流程

```
开始
  ↓
API: POST /api/roles/assign-user
Body: { user_id, role_ids: [1,2,3] }
  ↓
删除：该用户的旧角色关联
DELETE FROM user_roles WHERE user_id = ?
  ↓
批量插入：新角色关联
INSERT INTO user_roles (user_id, role_id)
  ↓
返回：成功
  ↓
结束
```

### 3.3 停用角色流程（替代删除）

```
开始
  ↓
前端：点击"编辑"按钮
  ↓
修改状态：status = 'inactive'
  ↓
API: PUT /api/roles/:id
Body: { status: 'inactive' }
  ↓
更新：roles 表
  ↓
updated_at 自动更新
  ↓
返回：成功
  ↓
前端：角色卡片显示"停用"标签
  ↓
结束

注意：
- user_roles 关联保留
- role_permissions 权限保留
- 权限系统应检查角色status，停用角色的权限不生效
```

### 3.4 获取用户角色流程

```
开始
  ↓
API: GET /api/roles/user/:userId
  ↓
查询：user_roles + roles 表关联
  ↓
过滤：只返回 status = 'active' 的角色（可选）
  ↓
返回：角色列表
  ↓
结束
```

---

## 四、测试场景

### 4.1 创建角色测试

#### 测试场景1：创建基础角色

**前置条件**:
- 已登录系统
- 有角色管理权限

**操作步骤**:
1. 访问 http://8.210.246.101:5002/roles.html
2. 点击"新建角色"按钮
3. 填写信息：
   - 角色代码：`test_role_001`
   - 角色名称：`测试角色001`
   - 角色描述：`用于测试的角色`
   - 数据权限范围：`组织数据(org)`
   - 状态：`启用`
4. 点击"保存角色"

**数据库验证SQL**:

```sql
-- 1. 验证角色创建
SELECT
    id, role_code, role_name, description,
    data_scope, status, is_deleted
FROM roles
WHERE role_code = 'test_role_001';

-- 预期结果：
-- role_code: test_role_001
-- role_name: 测试角色001
-- description: 用于测试的角色
-- data_scope: org
-- status: active
-- is_deleted: 0

-- 2. 验证创建时间
SELECT
    role_code,
    created_at,
    updated_at,
    created_by
FROM roles
WHERE role_code = 'test_role_001';

-- 预期结果：
-- created_at: (当前时间)
-- updated_at: (等于created_at)
-- created_by: (操作人ID，可能为NULL)
```

**预期结果**:
- ✅ roles表新增1条记录
- ✅ role_code唯一
- ✅ status默认为'active'
- ✅ is_deleted默认为0
- ✅ created_at和updated_at自动设置

#### 测试场景2：角色代码重复校验

**操作步骤**:
1. 创建角色：`test_role_001`（与已存在角色代码重复）
2. 保存

**数据库验证SQL**:

```sql
-- 验证唯一约束
SELECT COUNT(*) as count
FROM roles
WHERE role_code = 'test_role_001' AND is_deleted = 0;

-- 预期结果：
-- count: 1 (只有一个，创建失败)

-- 验证唯一索引
SHOW INDEX FROM roles WHERE Key_name = 'uk_role_code';

-- 预期：uk_role_code索引存在
```

**预期结果**:
- ❌ API返回409错误
- ❌ 提示"角色代码已存在"
- ✅ 数据库无新增记录

#### 测试场景3：创建带权限的角色

**操作步骤**:
1. 创建角色：`test_role_002`
2. 配置权限：
   - customer.view (查看客户)
   - customer.create (创建客户)
   - order.view (查看订单)
3. 保存

**数据库验证SQL**:

```sql
-- 验证角色和权限
SELECT
    r.role_code,
    r.role_name,
    COUNT(rp.id) as permission_count,
    GROUP_CONCAT(rp.permission_code ORDER BY rp.permission_code) as permissions
FROM roles r
LEFT JOIN role_permissions rp ON r.id = rp.role_id
WHERE r.role_code = 'test_role_002'
GROUP BY r.id;

-- 预期结果：
-- permission_count: 3
-- permissions: customer.create,customer.view,order.view
```

**预期结果**:
- ✅ roles表新增1条记录
- ✅ role_permissions表新增3条记录
- ✅ 每个权限记录的role_id相同

### 4.2 编辑角色测试

#### 测试场景4：修改角色基本信息

**前置条件**: 角色test_role_001已存在

**操作步骤**:
1. 点击test_role_001的"编辑"按钮
2. 修改：
   - 角色名称：`测试角色001-已修改`
   - 描述：`已更新的描述信息`
   - 数据权限：`全部数据(all)`
3. 保存

**数据库验证SQL**:

```sql
-- 验证信息更新
SELECT
    role_code, role_name, description,
    data_scope, updated_at
FROM roles
WHERE role_code = 'test_role_001';

-- 预期结果：
-- role_name: 测试角色001-已修改
-- description: 已更新的描述信息
-- data_scope: all
-- updated_at: (更新为当前时间)

-- 验证updated_at自动更新
SELECT
    created_at,
    updated_at,
    TIMESTAMPDIFF(SECOND, created_at, updated_at) as time_diff
FROM roles
WHERE role_code = 'test_role_001';

-- 预期：time_diff > 0
```

**预期结果**:
- ✅ 对应字段已更新
- ✅ updated_at自动更新
- ✅ role_code未改变（不可修改）

#### 测试场景5：修改角色权限

**前置条件**: test_role_002有3个权限

**操作步骤**:
1. 编辑test_role_002
2. 移除权限：`order.view`
3. 新增权限：`order.create`, `order.edit`
4. 保存

**数据库验证SQL**:

```sql
-- 验证权限变更
SELECT
    r.role_code,
    GROUP_CONCAT(rp.permission_code ORDER BY rp.permission_code) as permissions
FROM roles r
LEFT JOIN role_permissions rp ON r.id = rp.role_id
WHERE r.role_code = 'test_role_002'
GROUP BY r.id;

-- 预期结果：
-- permissions: customer.create,customer.view,order.create,order.edit
```

**预期结果**:
- ✅ 旧权限记录被删除
- ✅ 新权限记录被插入
- ✅ 最终权限数量正确（4个）

### 4.3 角色分配测试

#### 测试场景6：为用户分配单个角色

**前置条件**:
- 用户test_user_001已存在
- 角色test_role_001已存在

**API调用**:
```bash
curl -X POST http://localhost:5002/api/roles/assign-user \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 14,
    "role_ids": [1]
  }'
```

**数据库验证SQL**:

```sql
-- 验证角色分配
SELECT
    u.username,
    u.real_name,
    r.role_code,
    r.role_name,
    ur.created_at
FROM user_roles ur
JOIN users u ON ur.user_id = u.id
JOIN roles r ON ur.role_id = r.id
WHERE u.id = 14;

-- 预期结果：
-- 1条记录，role_id对应test_role_001
```

**预期结果**:
- ✅ user_roles表新增1条记录
- ✅ user_id和role_id正确关联

#### 测试场景7：为用户分配多个角色

**API调用**:
```bash
curl -X POST http://localhost:5002/api/roles/assign-user \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 14,
    "role_ids": [1, 3, 6]
  }'
```

**数据库验证SQL**:

```sql
-- 验证多角色分配
SELECT
    u.username,
    COUNT(ur.role_id) as role_count,
    GROUP_CONCAT(r.role_name ORDER BY r.role_name) as roles
FROM users u
LEFT JOIN user_roles ur ON u.id = ur.user_id
LEFT JOIN roles r ON ur.role_id = r.id
WHERE u.id = 14
GROUP BY u.id;

-- 预期结果：
-- role_count: 3
-- roles: (3个角色名称)
```

**预期结果**:
- ✅ 旧的user_roles记录被删除
- ✅ 新增3条user_roles记录

#### 测试场景8：移除用户的所有角色

**API调用**:
```bash
curl -X POST http://localhost:5002/api/roles/assign-user \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 14,
    "role_ids": []
  }'
```

**数据库验证SQL**:

```sql
-- 验证角色移除
SELECT COUNT(*) as role_count
FROM user_roles
WHERE user_id = 14;

-- 预期结果：
-- role_count: 0
```

**预期结果**:
- ✅ 该用户的所有user_roles记录被删除

### 4.4 角色状态管理

#### 测试场景9：停用角色

**操作步骤**:
1. 点击test_role_001的"编辑"按钮
2. 在"状态"下拉框中选择"停用"
3. 点击"保存角色"

**数据库验证SQL**:

```sql
-- 验证状态变更
SELECT role_code, status, updated_at
FROM roles
WHERE role_code = 'test_role_001';

-- 预期结果：
-- status: inactive
-- updated_at: (更新时间)

-- 验证用户角色关联保留
SELECT COUNT(*) as user_count
FROM user_roles
WHERE role_id = (SELECT id FROM roles WHERE role_code = 'test_role_001');

-- 预期结果：
-- user_count: (原有用户数，未变化)

-- 验证权限记录保留
SELECT COUNT(*) as permission_count
FROM role_permissions
WHERE role_id = (SELECT id FROM roles WHERE role_code = 'test_role_001');

-- 预期结果：
-- permission_count: (原有权限数，未变化)
```

**预期结果**:
- ✅ status从'active'变为'inactive'
- ✅ updated_at自动更新
- ✅ 已分配该角色的用户关联保留
- ✅ 角色权限配置保留
- ✅ 前端显示"停用"标签

#### 测试场景10：启用已停用的角色

**前置条件**: test_role_001状态为inactive

**操作步骤**:
1. 编辑test_role_001
2. 状态改为"启用"
3. 保存

**数据库验证SQL**:

```sql
-- 验证状态恢复
SELECT role_code, status, updated_at
FROM roles
WHERE role_code = 'test_role_001';

-- 预期结果：
-- status: active
-- updated_at: (更新时间)
```

**预期结果**:
- ✅ status从'inactive'变为'active'
- ✅ 角色重新可用
- ✅ 用户可以使用该角色的权限

### 4.5 删除功能测试（已禁用）

#### 测试场景11：验证删除功能已禁用

**⚠️ 功能说明**: 角色管理模块已禁用删除功能，角色只能通过状态管理（启用/停用）

**前端验证**:
1. 访问 http://8.210.246.101:5002/roles.html
2. 查看角色卡片操作按钮

**预期结果**:
- ✅ 只显示"编辑"和"查看权限"按钮
- ✅ 不显示"删除"按钮（红色垃圾桶图标）

**API验证**:

```bash
# 尝试调用DELETE接口
curl -X DELETE http://8.210.246.101:5002/api/roles/7

# 预期响应：
# 404 Not Found (路由不存在)
```

**替代方案验证**:

```sql
-- 通过停用角色实现"删除"效果
UPDATE roles
SET status = 'inactive'
WHERE role_code = 'test_role_001';

-- 验证
SELECT role_code, status FROM roles WHERE role_code = 'test_role_001';

-- 预期结果：
-- status: inactive
```

**业务规则说明**:
| 需求 | 删除方式（已禁用） | 状态管理方式（当前） |
|------|-------------------|---------------------|
| 移除角色 | DELETE或is_deleted=1 | status='inactive' ✅ |
| 数据保留 | ❌ 可能丢失审计记录 | ✅ 完整保留 |
| 可恢复性 | ❌ 难以恢复 | ✅ 随时启用 |
| 权限影响 | ❌ 用户失去角色引用 | ✅ 关联保留，权限失效 |
| 审计追溯 | ❌ 历史数据丢失 | ✅ 完整历史 |

---

## 五、统计功能测试

### 测试场景12：角色统计

**API**: `GET /api/roles/stats`

**数据库验证SQL**:

```sql
-- 手动计算统计数据
SELECT
    COUNT(*) as total,
    SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active_count,
    SUM(CASE WHEN status = 'inactive' THEN 1 ELSE 0 END) as inactive_count
FROM roles
WHERE is_deleted = 0;

-- 统计各角色的用户数
SELECT
    r.role_code,
    r.role_name,
    r.status,
    COUNT(DISTINCT ur.user_id) as user_count
FROM roles r
LEFT JOIN user_roles ur ON r.id = ur.role_id
WHERE r.is_deleted = 0
GROUP BY r.id
ORDER BY user_count DESC;

-- 统计各状态的角色分布
SELECT
    status,
    COUNT(*) as count,
    ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM roles WHERE is_deleted = 0), 2) as percentage
FROM roles
WHERE is_deleted = 0
GROUP BY status;
```

**预期结果**:
- ✅ API返回的统计数据与SQL查询一致
- ✅ 包含总数、活跃数、停用数

---

## 六、数据权限范围测试

### 测试场景13：验证数据权限控制

**前置条件**: 创建不同data_scope的角色

**测试数据准备**:

```sql
-- 创建测试角色
INSERT INTO roles (role_code, role_name, description, data_scope, status, created_by)
VALUES
    ('test_all', '全局管理员', '可查看所有数据', 'all', 'active', 1),
    ('test_org', '组织管理员', '可查看组织数据', 'org', 'active', 1),
    ('test_store', '门店管理员', '可查看门店数据', 'store', 'active', 1),
    ('test_self', '普通员工', '只能查看个人数据', 'self', 'active', 1);

-- 分配给不同用户
INSERT INTO user_roles (user_id, role_id, created_by)
SELECT 1, id, 1 FROM roles WHERE role_code = 'test_all' UNION
SELECT 2, id, 1 FROM roles WHERE role_code = 'test_org' UNION
SELECT 3, id, 1 FROM roles WHERE role_code = 'test_store' UNION
SELECT 4, id, 1 FROM roles WHERE role_code = 'test_self';
```

**验证SQL**:

```sql
-- 验证用户的数据权限范围
SELECT
    u.username,
    u.real_name,
    r.role_name,
    r.data_scope,
    CASE r.data_scope
        WHEN 'all' THEN '可查看所有组织数据'
        WHEN 'org' THEN '可查看本组织数据'
        WHEN 'store' THEN '可查看本门店数据'
        WHEN 'self' THEN '只能查看个人数据'
    END as permission_desc
FROM users u
JOIN user_roles ur ON u.id = ur.user_id
JOIN roles r ON ur.role_id = r.id
WHERE u.id IN (1,2,3,4) AND r.status = 'active'
ORDER BY u.id;
```

**预期结果**:
- ✅ 每个用户的data_scope正确设置
- ✅ 可用于后续业务权限控制
- ✅ 只有status='active'的角色权限生效

---

## 七、边界条件测试

### 7.1 字段长度测试

```sql
-- 测试角色代码最大长度（50字符）
INSERT INTO roles (role_code, role_name, data_scope, created_by)
VALUES (
    '12345678901234567890123456789012345678901234567890', -- 50字符
    '测试角色',
    'self',
    1
);

-- 预期：成功

-- 测试超长角色代码（51字符）
INSERT INTO roles (role_code, role_name, data_scope, created_by)
VALUES (
    '123456789012345678901234567890123456789012345678901', -- 51字符
    '测试角色',
    'self',
    1
);

-- 预期：失败，超出长度限制
```

### 7.2 必填字段测试

```sql
-- 测试缺少必填字段
INSERT INTO roles (role_code) -- 缺少role_name
VALUES ('test');

-- 预期：失败，NOT NULL约束

-- 测试缺少role_name
INSERT INTO roles (role_code, data_scope)
VALUES ('test2', 'self');

-- 预期：失败，NOT NULL约束
```

### 7.3 枚举值测试

```sql
-- 测试非法data_scope值
INSERT INTO roles (role_code, role_name, data_scope)
VALUES ('test', '测试', 'invalid_scope');

-- 预期：失败，枚举值约束

-- 测试非法status值
UPDATE roles
SET status = 'invalid_status'
WHERE id = 1;

-- 预期：失败，枚举值约束

-- 测试有效的status值
UPDATE roles
SET status = 'inactive'
WHERE role_code = 'test_role_001';

-- 预期：成功
```

### 7.4 角色代码不可修改测试

```sql
-- 尝试修改角色代码
UPDATE roles
SET role_code = 'new_code'
WHERE role_code = 'test_role_001';

-- 预期：API层面阻止（403错误）
-- 数据库层面：可以更新，但业务逻辑应该禁止
```

---

## 八、性能测试SQL

### 8.1 索引效率测试

```sql
-- 测试role_code唯一索引
EXPLAIN SELECT * FROM roles WHERE role_code = 'test_role_001';
-- 预期：type=const, key=uk_role_code

-- 测试status索引
EXPLAIN SELECT * FROM roles WHERE status = 'active';
-- 预期：type=ref, key=idx_status

-- 测试角色用户关联查询
EXPLAIN
SELECT r.*, COUNT(ur.user_id) as user_count
FROM roles r
LEFT JOIN user_roles ur ON r.id = ur.role_id
WHERE r.is_deleted = 0 AND r.status = 'active'
GROUP BY r.id;
-- 验证索引使用情况
```

### 8.2 批量操作性能

```sql
-- 批量分配角色
START TRANSACTION;

DELETE FROM user_roles WHERE user_id = 1;

INSERT INTO user_roles (user_id, role_id, created_by)
SELECT 1, id, 1
FROM roles
WHERE id IN (1,2,3,4,5) AND status = 'active';

COMMIT;

-- 验证执行时间和影响行数
SELECT ROW_COUNT() as affected_rows;
```

---

## 九、数据完整性检查

### 9.1 孤儿记录检查

```sql
-- 检查role_permissions中是否有孤儿记录
SELECT rp.id, rp.role_id, rp.permission_code
FROM role_permissions rp
LEFT JOIN roles r ON rp.role_id = r.id
WHERE r.id IS NULL;

-- 预期结果：0条记录

-- 检查user_roles中的角色是否有效
SELECT ur.id, ur.role_id, ur.user_id, r.status
FROM user_roles ur
LEFT JOIN roles r ON ur.role_id = r.id
WHERE r.id IS NULL;

-- 预期结果：0条记录

-- 检查停用角色的用户关联（正常情况）
SELECT
    r.role_code,
    r.status,
    COUNT(ur.user_id) as user_count
FROM roles r
LEFT JOIN user_roles ur ON r.id = ur.role_id
WHERE r.status = 'inactive'
GROUP BY r.id;

-- 说明：停用角色可以有用户关联，这是正常的
```

### 9.2 数据一致性检查

```sql
-- 检查角色用户数统计
SELECT
    r.role_code,
    r.role_name,
    r.status,
    COUNT(DISTINCT ur.user_id) as actual_user_count
FROM roles r
LEFT JOIN user_roles ur ON r.id = ur.role_id
WHERE r.is_deleted = 0
GROUP BY r.id
ORDER BY actual_user_count DESC;

-- 检查唯一约束完整性
SELECT role_code, COUNT(*) as count
FROM roles
WHERE is_deleted = 0
GROUP BY role_code
HAVING count > 1;

-- 预期结果：0条记录

-- 检查status字段有效性
SELECT status, COUNT(*) as count
FROM roles
WHERE is_deleted = 0
GROUP BY status;

-- 预期结果：只有 'active' 和 'inactive' 两种状态
```

---

## 十、角色权限配置测试

### 10.1 权限代码规范测试

**推荐权限命名规范**: `资源.操作`

```sql
-- 检查权限代码格式
SELECT
    rp.permission_code,
    CASE
        WHEN rp.permission_code REGEXP '^[a-z_]+\\.[a-z_]+$' THEN '✅ 格式正确'
        ELSE '❌ 格式错误'
    END as format_check
FROM role_permissions rp
GROUP BY rp.permission_code;
```

**常用权限示例**:

| 权限代码 | 说明 | 资源类型 |
|----------|------|---------|
| customer.view | 查看客户 | customer |
| customer.create | 创建客户 | customer |
| customer.edit | 编辑客户 | customer |
| customer.delete | 删除客户 | customer |
| order.view | 查看订单 | order |
| order.create | 创建订单 | order |
| order.edit | 编辑订单 | order |
| order.cancel | 取消订单 | order |
| user.manage | 管理用户 | user |
| role.manage | 管理角色 | role |
| org.manage | 组织管理 | org |
| system.config | 系统配置 | system |

### 10.2 权限完整性测试

```sql
-- 检查各角色的权限配置
SELECT
    r.role_code,
    r.role_name,
    r.status,
    COUNT(rp.id) as permission_count,
    GROUP_CONCAT(rp.permission_code ORDER BY rp.permission_code SEPARATOR ', ') as permissions
FROM roles r
LEFT JOIN role_permissions rp ON r.id = rp.role_id
WHERE r.is_deleted = 0
GROUP BY r.id
ORDER BY permission_count DESC;

-- 检查停用角色的权限保留
SELECT
    r.role_code,
    r.status,
    COUNT(rp.id) as permission_count
FROM roles r
LEFT JOIN role_permissions rp ON r.id = rp.role_id
WHERE r.status = 'inactive'
GROUP BY r.id;

-- 预期：停用角色的权限配置仍然保留
```

---

## 十一、系统预置角色验证

### 11.1 预置角色列表

```sql
-- 验证系统预置角色
SELECT
    id, role_code, role_name, description,
    data_scope, status, created_at
FROM roles
WHERE role_code IN (
    'admin',
    'store_manager',
    'beautician',
    'sales',
    'customer_service',
    'data_analyst'
)
ORDER BY id;
```

**预期结果**:

| role_code | role_name | data_scope | status | 说明 |
|-----------|-----------|------------|--------|------|
| admin | 系统管理员 | all | active | 拥有所有权限 |
| store_manager | 门店经理 | org | active | 管理门店运营 |
| beautician | 美容顾问 | self | active | 客户接待服务 |
| sales | 销售专员 | self | active | 产品销售 |
| customer_service | 客服人员 | org | active | 客户咨询服务 |
| data_analyst | 数据分析师 | all | active | 数据分析 |

### 11.2 预置角色用户分配验证

```sql
-- 统计各预置角色的用户数
SELECT
    r.role_code,
    r.role_name,
    r.status,
    COUNT(DISTINCT ur.user_id) as user_count,
    GROUP_CONCAT(DISTINCT u.real_name ORDER BY u.real_name) as users
FROM roles r
LEFT JOIN user_roles ur ON r.id = ur.role_id
LEFT JOIN users u ON ur.user_id = u.id AND u.is_deleted = 0
WHERE r.role_code IN (
    'admin', 'store_manager', 'beautician',
    'sales', 'customer_service', 'data_analyst'
)
GROUP BY r.id
ORDER BY user_count DESC;
```

---

## 十二、测试数据清理

### 测试完成后的清理脚本

```sql
-- 1. 删除测试角色的权限
DELETE FROM role_permissions
WHERE role_id IN (
    SELECT id FROM roles
    WHERE role_code LIKE 'test_%'
);

-- 2. 删除测试角色的用户关联
DELETE FROM user_roles
WHERE role_id IN (
    SELECT id FROM roles
    WHERE role_code LIKE 'test_%'
);

-- 3. 删除测试角色（物理删除，仅用于测试清理）
DELETE FROM roles
WHERE role_code LIKE 'test_%';

-- 4. 验证清理结果
SELECT COUNT(*) as remaining_test_roles
FROM roles
WHERE role_code LIKE 'test_%';

-- 预期结果：0

-- 5. 验证正常角色未受影响
SELECT COUNT(*) as normal_roles
FROM roles
WHERE role_code NOT LIKE 'test_%' AND is_deleted = 0;
```

---

## 十三、常见问题排查

### 问题1：创建角色失败

**排查SQL**:
```sql
-- 检查角色代码是否已存在
SELECT id, role_code, status, is_deleted
FROM roles
WHERE role_code = 'xxx';

-- 检查字段值是否合法
SELECT
    'test_code' as role_code,
    'test' as role_name,
    'self' as data_scope,
    'active' as status;
```

### 问题2：角色分配失败

**排查SQL**:
```sql
-- 检查用户是否存在
SELECT id, username, is_deleted
FROM users
WHERE id = xxx;

-- 检查角色是否存在且启用
SELECT id, role_code, status, is_deleted
FROM roles
WHERE id IN (1,2,3);

-- 检查是否已有重复关联
SELECT * FROM user_roles
WHERE user_id = xxx AND role_id = xxx;
```

### 问题3：角色权限不生效

**排查SQL**:
```sql
-- 检查角色状态
SELECT
    r.role_code,
    r.role_name,
    r.status,
    COUNT(rp.id) as permission_count
FROM roles r
LEFT JOIN role_permissions rp ON r.id = rp.role_id
WHERE r.id = xxx
GROUP BY r.id;

-- 如果status='inactive'，权限应该不生效

-- 检查用户的有效角色和权限
SELECT
    u.username,
    r.role_code,
    r.role_name,
    r.status,
    GROUP_CONCAT(rp.permission_code) as permissions
FROM users u
JOIN user_roles ur ON u.id = ur.user_id
JOIN roles r ON ur.role_id = r.id
LEFT JOIN role_permissions rp ON r.id = rp.role_id
WHERE u.id = xxx
GROUP BY r.id;

-- 只有status='active'的角色权限应该生效
```

### 问题4：为什么不能删除角色？

**回答**:
- **业务规则**: 角色管理模块禁用了删除功能
- **原因**:
  1. 保护权限系统稳定性
  2. 保留审计追溯数据
  3. 避免用户角色关联丢失
  4. 支持角色重新启用
- **替代方案**: 使用状态管理（停用角色）

**验证SQL**:
```sql
-- 停用角色而非删除
UPDATE roles
SET status = 'inactive', updated_at = CURRENT_TIMESTAMP
WHERE role_code = 'xxx';

-- 验证停用结果
SELECT role_code, role_name, status, updated_at
FROM roles
WHERE role_code = 'xxx';
```

---

## 十四、测试检查清单

### 功能测试
- [ ] 创建基础角色
- [ ] 角色代码重复校验
- [ ] 创建带权限的角色
- [ ] 修改角色基本信息
- [ ] 修改角色权限
- [ ] 为用户分配单个角色
- [ ] 为用户分配多个角色
- [ ] 移除用户的所有角色
- [ ] 停用角色
- [ ] 启用已停用的角色
- [ ] ~~删除角色~~（功能已禁用）
- [ ] 验证删除功能已禁用
- [ ] 角色统计准确性

### 数据库测试
- [ ] roles表记录正确插入
- [ ] role_permissions表记录正确插入
- [ ] user_roles表记录正确插入/删除
- [ ] 唯一约束生效
- [ ] 外键约束生效
- [ ] 索引使用正确
- [ ] ~~软删除逻辑~~（当前不使用删除）
- [ ] 状态管理逻辑正确
- [ ] 时间戳自动更新

### 权限测试
- [ ] data_scope正确设置
- [ ] 权限代码格式规范
- [ ] 权限配置完整性
- [ ] 停用角色权限不生效
- [ ] 启用角色权限恢复

### 状态管理测试
- [ ] 状态枚举值有效
- [ ] 停用操作正确
- [ ] 启用操作正确
- [ ] 状态变更记录updated_at
- [ ] 停用角色数据保留

### 边界测试
- [ ] 字段长度限制
- [ ] 必填字段校验
- [ ] 枚举值校验
- [ ] 角色代码不可修改

### 性能测试
- [ ] 索引效率
- [ ] 批量操作性能
- [ ] 关联查询性能

---

## 附录A：快速测试脚本

```sql
-- 完整测试流程脚本

-- 1. 创建测试角色
INSERT INTO roles (role_code, role_name, description, data_scope, status, created_by)
VALUES ('test_auto_role', '自动测试角色', '用于自动化测试', 'org', 'active', 1);

SET @test_role_id = LAST_INSERT_ID();

-- 2. 配置权限
INSERT INTO role_permissions (role_id, permission_code, resource_type, created_by)
VALUES
    (@test_role_id, 'customer.view', 'customer', 1),
    (@test_role_id, 'customer.create', 'customer', 1),
    (@test_role_id, 'order.view', 'order', 1);

-- 3. 分配给用户
INSERT INTO user_roles (user_id, role_id, created_by)
VALUES (1, @test_role_id, 1);

-- 4. 验证创建
SELECT
    r.id, r.role_code, r.role_name, r.status,
    COUNT(rp.id) as permission_count,
    COUNT(DISTINCT ur.user_id) as user_count
FROM roles r
LEFT JOIN role_permissions rp ON r.id = rp.role_id
LEFT JOIN user_roles ur ON r.id = ur.role_id
WHERE r.id = @test_role_id
GROUP BY r.id;

-- 预期：permission_count=3, user_count=1, status='active'

-- 5. 更新角色
UPDATE roles
SET role_name = '自动测试角色-已修改', data_scope = 'all'
WHERE id = @test_role_id;

-- 6. 停用角色
UPDATE roles SET status = 'inactive' WHERE id = @test_role_id;

-- 7. 验证停用（数据保留）
SELECT
    r.id, r.role_code, r.status,
    COUNT(rp.id) as permission_count,
    COUNT(DISTINCT ur.user_id) as user_count
FROM roles r
LEFT JOIN role_permissions rp ON r.id = rp.role_id
LEFT JOIN user_roles ur ON r.id = ur.role_id
WHERE r.id = @test_role_id
GROUP BY r.id;

-- 预期：status='inactive', 但permission_count和user_count仍保留

-- 8. 重新启用角色
UPDATE roles SET status = 'active' WHERE id = @test_role_id;

-- 9. 验证启用
SELECT role_code, status FROM roles WHERE id = @test_role_id;

-- 预期：status='active'

-- 10. 清理测试数据（物理删除，仅用于测试清理）
DELETE FROM user_roles WHERE role_id = @test_role_id;
DELETE FROM role_permissions WHERE role_id = @test_role_id;
DELETE FROM roles WHERE id = @test_role_id;

-- 11. 验证清理
SELECT COUNT(*) as remaining FROM roles WHERE id = @test_role_id;

-- 预期：remaining = 0
```

---

## 附录B：监控查询

```sql
-- 实时监控角色变化
SELECT
    DATE(created_at) as date,
    COUNT(*) as new_roles
FROM roles
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
  AND is_deleted = 0
GROUP BY DATE(created_at)
ORDER BY date DESC;

-- 统计角色使用情况
SELECT
    r.role_code,
    r.role_name,
    r.status,
    COUNT(DISTINCT ur.user_id) as user_count,
    COUNT(rp.id) as permission_count,
    r.data_scope
FROM roles r
LEFT JOIN user_roles ur ON r.id = ur.role_id
LEFT JOIN role_permissions rp ON r.id = rp.role_id
WHERE r.is_deleted = 0
GROUP BY r.id
ORDER BY user_count DESC;

-- 权限分布统计
SELECT
    rp.permission_code,
    COUNT(DISTINCT rp.role_id) as role_count,
    GROUP_CONCAT(DISTINCT r.role_name) as roles
FROM role_permissions rp
JOIN roles r ON rp.role_id = r.id
WHERE r.is_deleted = 0 AND r.status = 'active'
GROUP BY rp.permission_code
ORDER BY role_count DESC;

-- 状态分布统计
SELECT
    status,
    COUNT(*) as count,
    ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM roles WHERE is_deleted = 0), 2) as percentage
FROM roles
WHERE is_deleted = 0
GROUP BY status;

-- 停用角色监控
SELECT
    r.role_code,
    r.role_name,
    r.updated_at as disabled_at,
    COUNT(DISTINCT ur.user_id) as affected_users
FROM roles r
LEFT JOIN user_roles ur ON r.id = ur.role_id
WHERE r.status = 'inactive' AND r.is_deleted = 0
GROUP BY r.id
ORDER BY r.updated_at DESC;
```

---

## 附录C：角色权限矩阵示例

| 功能模块 | 系统管理员 | 门店经理 | 美容顾问 | 销售专员 | 客服人员 | 数据分析师 |
|---------|----------|---------|---------|---------|---------|-----------|
| 查看客户 | ✅ all | ✅ org | ✅ self | ✅ self | ✅ org | ✅ all |
| 创建客户 | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ |
| 编辑客户 | ✅ | ✅ | ✅ self | ✅ self | ✅ | ❌ |
| 删除客户 | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ |
| 查看订单 | ✅ all | ✅ org | ✅ self | ✅ self | ✅ org | ✅ all |
| 创建订单 | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ |
| 管理用户 | ✅ | ✅ org | ❌ | ❌ | ❌ | ❌ |
| 管理角色 | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |
| 数据分析 | ✅ | ✅ org | ❌ | ❌ | ❌ | ✅ all |

---

## 附录D：API接口清单

| 方法 | 路径 | 说明 | 必需参数 |
|------|------|------|---------|
| GET | /api/roles | 获取角色列表（分页） | page, pageSize |
| GET | /api/roles/:id | 获取单个角色 | id |
| GET | /api/roles/stats | 获取角色统计 | - |
| POST | /api/roles | 创建角色 | role_code, role_name |
| PUT | /api/roles/:id | 更新角色 | id |
| ~~DELETE~~ | ~~/api/roles/:id~~ | ~~删除角色~~（已禁用） | - |
| POST | /api/roles/assign-user | 为用户分配角色 | user_id, role_ids |
| GET | /api/roles/user/:userId | 获取用户的角色列表 | userId |

**注意**:
- ❌ DELETE接口已禁用
- ✅ 使用PUT接口修改status字段实现停用

---

## 附录E：状态管理最佳实践

### 1. 停用角色的场景
- 角色职责已变更，不再使用
- 角色权限需要重新规划
- 临时禁用某些角色的权限
- 角色即将被新角色替代

### 2. 停用 vs 删除对比

| 维度 | 停用（推荐） | 删除（已禁用） |
|------|-------------|---------------|
| 数据保留 | ✅ 完整保留 | ❌ 可能丢失 |
| 用户关联 | ✅ 保留 | ❌ 丢失 |
| 权限配置 | ✅ 保留 | ❌ 丢失 |
| 可恢复性 | ✅ 随时启用 | ❌ 难以恢复 |
| 审计追溯 | ✅ 完整历史 | ❌ 历史丢失 |
| 数据安全 | ✅ 安全 | ⚠️ 风险高 |

### 3. 权限验证建议

```javascript
// 获取用户有效权限（示例代码）
async function getUserPermissions(userId) {
  const userRoles = await UserRole.findByUserId(userId);
  const permissions = new Set();

  for (const roleId of userRoles) {
    const role = await Role.findById(roleId);

    // ✅ 只有启用状态的角色才赋予权限
    if (role && role.status === 'active') {
      role.permissions.forEach(p => permissions.add(p));
    }
  }

  return Array.from(permissions);
}
```

---

**测试负责人**: _________
**测试日期**: _________
**测试结果**: ☐ 通过  ☐ 部分通过  ☐ 未通过
**备注**: _________
